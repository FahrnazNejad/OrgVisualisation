<!DOCTYPE html>
<meta charset="utf-8">
<title>Org Circle Packing + Clickable Context Org Tree</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    flex-direction: row;
    height: 100vh;
    overflow: hidden;
  }
  #viz-container {
    flex: 1;
    position: relative;
  }
  #org-panel {
    flex: 1;
    border-left: 1px solid #ddd;
    font-size: 13px;
    overflow: hidden;
    background: #fafafa;
    position: relative;
  }
  svg {
    width: 100%;
    height: 100%;
    display: block;
    background: #f7f7f7;
  }
  .node {
    cursor: pointer;
  }
  .node:hover {
    stroke: #000;
    stroke-width: 1.5px;
  }
  .node--leaf {
    fill: white;
  }
  .label {
    font-size: 11px;
    text-anchor: middle;
    pointer-events: none;
  }
  .tooltip {
    position: absolute;
    padding: 6px 8px;
    background: rgba(0,0,0,0.8);
    color: #fff;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    opacity: 0;
  }
  #search-container {
    position: fixed;
    top: 10px;
    right: 16px;
    z-index: 10;
  }
  #search-input {
    padding: 4px 6px;
    font-size: 13px;
  }
  #search-button {
    padding: 4px 8px;
    font-size: 13px;
    margin-left: 4px;
  }
  #org-tree-svg {
    width: 100%;
    height: 100%;
  }
  .org-node rect {
    fill: #f5e3d3;
    stroke: #d4c0af;
    rx: 6;
    ry: 6;
  }
  .org-node text {
    font-size: 11px;
    text-anchor: middle;
  }
  .org-link {
    fill: none;
    stroke: #999;
    stroke-width: 1.2px;
  }
</style>

<body>
<div id="viz-container">
  <div id="tooltip" class="tooltip"></div>

  <div id="search-container">
    <input id="search-input" type="text" placeholder="Search person..." />
    <button id="search-button">Search</button>
  </div>

  <svg id="circle-svg"></svg>
</div>

<div id="org-panel">
  <svg id="org-tree-svg"></svg>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const circleSvg = d3.select("#circle-svg");
const width  = document.getElementById("viz-container").clientWidth;
const height = document.getElementById("viz-container").clientHeight;
const margin = 20;

const g = circleSvg.append("g")
  .attr("transform", `translate(${width / 2},${height / 2})`);

const color = d3.scaleOrdinal()
  .domain(["company","portfolio","value_stream","art","product_team","person"])
  .range(["#f1f1f1","#c7e9c0","#9ecae1","#fdd0a2","#d4b9da","#ffffff"]);

const pack = d3.pack()
  .size([width - 2 * margin, height - 2 * margin])
  .padding(3);

const tooltip = d3.select("#tooltip");
const MIN_LABEL_RADIUS = 18;

// org tree
const orgSvg = d3.select("#org-tree-svg");
const orgWidth  = document.getElementById("org-panel").clientWidth;
const orgHeight = document.getElementById("org-panel").clientHeight;
const orgG = orgSvg.append("g")
  .attr("transform", `translate(${orgWidth / 2}, 40)`);

const treeLayout = d3.tree()
  .size([orgWidth - 160, orgHeight - 160]);

const boxWidth = 130;
const boxHeight = 50;

d3.json("employees_hierarchy.json").then(data => {
  // ------------ circle packing ------------
  const root = d3.hierarchy(data)
    .sum(d => d.level === "person" ? 1 : 0)
    .sort((a, b) => b.value - a.value);

  const nodes = pack(root).descendants();
  let focus = root;
  let view;

  const circle = g.selectAll("circle")
    .data(nodes)
    .join("circle")
      .attr("class", d =>
        d.parent ? (d.children ? "node" : "node node--leaf") : "node node--root"
      )
      .attr("fill", d => color(d.data.level || (d.children ? "company" : "person")))
      .on("click", (event, d) => {
        if (!d.children && d.data.level === "person") {
          renderContextTree(d.data.userId);
        }
        if (focus !== d) {
          zoom(event, d);
          event.stopPropagation();
        }
      })
      .on("mousemove", (event, d) => {
        if (!d.children && d.data.level === "person") {
          const p = d.data;
          tooltip
            .style("opacity", 1)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px")
            .html(
              `<strong>${p.name}</strong><br>
               ${p.title || ""}<br>
               ${p.department || ""}<br>
               ${p.location || ""}`
            );
        }
      })
      .on("mouseleave", () => {
        tooltip.style("opacity", 0);
      });

  const text = g.selectAll("text.node-label")
    .data(nodes.filter(d => d !== root))
    .join("text")
      .attr("class", "label node-label")
      .text(d => d.data.name);

  const node = g.selectAll("circle,text.node-label");

  const focusLabel = g.append("text")
    .attr("class", "label")
    .attr("font-weight", "bold")
    .attr("text-anchor", "middle")
    .style("pointer-events", "none");

  const companyGroup = g.append("g").style("pointer-events", "none");
  const companyBg = companyGroup.append("rect")
    .attr("rx", 4)
    .attr("ry", 4)
    .attr("fill", "black");
  const companyTextCompany = companyGroup.append("text")
    .attr("dominant-baseline", "middle")
    .attr("text-anchor", "end")
    .attr("fill", "white")
    .attr("font-weight", "bold")
    .text("Company");
  const companyTextOrg = companyGroup.append("text")
    .attr("dominant-baseline", "middle")
    .attr("text-anchor", "start")
    .attr("fill", "red")
    .attr("font-weight", "bold")
    .text("Organization");

  circleSvg.on("click", event => zoom(event, root));

  zoomTo(targetView(root));

  function targetView(d) {
    const r = d.r;
    const safety = 0.8;
    const usableWidth  = (width  - 2 * margin) * safety;
    const usableHeight = (height - 2 * margin) * safety;
    const scaleX = usableWidth  / (2 * r);
    const scaleY = usableHeight / (2 * r);
    const scale = Math.min(scaleX, scaleY);
    const size = width / scale;
    return [d.x, d.y, size];
  }

  function zoom(event, d) {
    focus = d;
    const target = targetView(focus);

    circleSvg.transition()
      .duration(event && event.altKey ? 7500 : 750)
      .tween("zoom", () => {
        const i = d3.interpolateZoom(view, target);
        return t => zoomTo(i(t));
      });
  }

  function zoomTo(v) {
    const k = width / v[2];
    view = v;

    node.attr("transform", d =>
      `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
    );
    circle.attr("r", d => d.r * k);

    text.style("display", d =>
      d.parent === focus && d.r * k >= MIN_LABEL_RADIUS ? "inline" : "none"
    );

    const fx = (focus.x - v[0]) * k;
    const fy = (focus.y - v[1]) * k;
    const fr = focus.r * k;

    focusLabel
      .attr("x", fx)
      .attr("y", fy - fr + 14)
      .text(focus.data.name || "")
      .style("display", fr > 25 ? "inline" : "none");

    const rootX = (root.x - v[0]) * k;
    const rootY = (root.y - v[1]) * k;
    const rootR = root.r * k;

    const pillWidth = 240;
    const pillHeight = 30;

    companyGroup
      .attr("transform", `translate(${rootX},${rootY - rootR + pillHeight/2 + 6})`)
      .style("display", rootR > 40 ? "inline" : "none");

    companyBg
      .attr("x", -pillWidth / 2)
      .attr("y", -pillHeight / 2)
      .attr("width", pillWidth)
      .attr("height", pillHeight);

    companyTextCompany
      .attr("x", -10)
      .attr("y", 0);

    companyTextOrg
      .attr("x", 0)
      .attr("y", 0);
  }

  // --------- flat people + reporting relationships ----------
  const people = [];
  root.each(d => {
    if (!d.children && d.data.level === "person") {
      people.push(d.data);
    }
  });

  const nodeById = new Map();
  people.forEach(p => {
    nodeById.set(p.userId, {
      id: p.userId,
      name: p.name,
      title: p.title || p.role || "",
      manager_id: p.manager_id,
      children: []
    });
  });

  nodeById.forEach(n => { n.children = []; });
  nodeById.forEach(n => {
    if (n.manager_id && nodeById.has(n.manager_id)) {
      nodeById.get(n.manager_id).children.push(n);
    }
  });

  // ---------- search ----------
  const input = document.getElementById("search-input");
  const button = document.getElementById("search-button");

  function findPersonNodeCircleByName(name) {
    const n = name.trim().toLowerCase();
    if (!n) return null;
    return nodes.find(d =>
      !d.children &&
      d.data.level === "person" &&
      d.data.name &&
      d.data.name.toLowerCase() === n
    ) || null;
  }

  button.addEventListener("click", () => {
    const val = input.value;
    const nCircle = findPersonNodeCircleByName(val);
    if (nCircle) {
      const targetNode = nCircle.parent || nCircle;
      zoom(null, targetNode);
      renderContextTree(nCircle.data.userId);
    }
  });

  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      button.click();
    }
  });

  // ---------- context tree: managers chain + clickable reports ----------
  function buildContextData(userId) {
    if (!nodeById.has(userId)) return null;

    const person = nodeById.get(userId);

    // manager chain (top -> person)
    const chain = [];
    let current = person;
    while (current) {
      chain.unshift(current);
      if (!current.manager_id || !nodeById.has(current.manager_id)) break;
      current = nodeById.get(current.manager_id);
    }

    function cloneBase(n) {
      return {
        id: n.id,
        name: n.name,
        title: n.title,
        children: null,
        _children: null
      };
    }

    function cloneReportsForCollapsible(n) {
      const c = cloneBase(n);
      if (n.children && n.children.length) {
        c.children = n.children.map(ch => cloneReportsForCollapsible(ch));
      }
      return c;
    }

    let contextRoot = null;
    let prevClone = null;

    for (let i = 0; i < chain.length; i++) {
      const original = chain[i];
      const isSelected = original.id === person.id;
      const cloned = isSelected ? cloneReportsForCollapsible(original) : cloneBase(original);

      if (prevClone) {
        prevClone.children = prevClone.children || [];
        prevClone.children.push(cloned);
      } else {
        contextRoot = cloned;
      }
      prevClone = cloned;
    }

    return contextRoot;
  }

  function renderContextTree(userId) {
    orgG.selectAll("*").remove();
    const treeData = buildContextData(userId);
    if (!treeData) return;

    const hRoot = d3.hierarchy(treeData);

    const hasReports = hRoot.descendants().some(d => d.depth > 0);
    if (!hasReports) {
      const x = 0, y = 0;
      orgG.attr("transform", `translate(${orgWidth / 2}, 80)`);

      const gNode = orgG.append("g")
        .attr("class", "org-node")
        .attr("transform", `translate(${x},${y})`);

      gNode.append("rect")
        .attr("x", -boxWidth / 2)
        .attr("y", -boxHeight / 2)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("stroke", "#d62728")
        .attr("stroke-width", 2);

      gNode.append("text")
        .attr("y", -6)
        .text(hRoot.data.name);

      gNode.append("text")
        .attr("y", 10)
        .attr("fill", "#555")
        .text(hRoot.data.title || "");

      return;
    }

    // collapse reports initially (manager chain open)
    hRoot.each(d => {
      const isOnChain = d.ancestors().some(a => a.data.id === userId);
      if (!isOnChain && d.depth > 0 && d.children) {
        d._children = d.children;
        d.children = null;
      }
    });

    update(hRoot);

    function update(source) {
      treeLayout(hRoot);
      const nodesT = hRoot.descendants();
      const linksT = hRoot.links();

      nodesT.forEach(d => {
        d.y = d.depth * 80;
      });

      const minX = d3.min(nodesT, d => d.x);
      const maxX = d3.max(nodesT, d => d.x);
      const xShift = - (minX + maxX) / 2;
      orgG.attr("transform", `translate(${orgWidth / 2}, 40)`);

      orgG.selectAll(".org-link")
        .data(linksT)
        .join("path")
        .attr("class", "org-link")
        .attr("d", d => `
          M ${d.source.x + xShift},${d.source.y}
          V ${(d.source.y + d.target.y) / 2}
          H ${d.target.x + xShift}
          V ${d.target.y}
        `);

      const nodeG = orgG.selectAll(".org-node")
        .data(nodesT)
        .join("g")
        .attr("class", "org-node")
        .attr("transform", d => `translate(${d.x + xShift},${d.y})`)
        .on("click", (event, d) => {
          event.stopPropagation();
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else if (d._children) {
            d.children = d._children;
            d._children = null;
          }
          update(d);
        });

      nodeG.selectAll("rect").remove();
      nodeG.selectAll("text").remove();

      nodeG.append("rect")
        .attr("x", -boxWidth / 2)
        .attr("y", -boxHeight / 2)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("stroke", d => d.data.id === userId ? "#d62728" : "#d4c0af")
        .attr("stroke-width", d => d.data.id === userId ? 2 : 1.2);

      nodeG.append("text")
        .attr("y", -6)
        .text(d => d.data.name);

      nodeG.append("text")
        .attr("y", 10)
        .attr("fill", "#555")
        .text(d => d.data.title || "");
    }
  }

  // right side starts empty
  orgG.selectAll("*").remove();
});
</script>
</body>
