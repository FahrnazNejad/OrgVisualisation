<!DOCTYPE html>
<meta charset="utf-8" />
<title>Org Circle + Manager Chain Panel + Tree Tab</title>

<style>
  body {
    margin: 0;
    font-family: system-ui, -apple-system, sans-serif;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* top black ribbon */
  #top-ribbon {
    width: 100%;
    background: #000000;
    color: #ffffff;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 700;
  }
  #top-ribbon .brand-white { color: #ffffff; margin-right: 4px; }
  #top-ribbon .brand-red { color: #ff3b30; }

  #tabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    background: #fafafa;
    z-index: 10;
  }
  .tab-btn {
    padding: 10px 20px;
    cursor: pointer;
    border: none;
    border-right: 1px solid #ddd;
    background: #f0f0f0;
    font-size: 13px;
  }
  .tab-btn.active {
    background: #ffffff;
    font-weight: 600;
    border-bottom: 2px solid #007bff;
  }
  #search-container {
    margin-left: auto;
    padding: 6px 12px;
  }
  #search-input {
    padding: 5px 8px;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  #search-button {
    padding: 5px 12px;
    font-size: 13px;
    margin-left: 4px;
    cursor: pointer;
  }

  #content {
    flex: 1;
    position: relative;
    background: #f7f7f7;
  }

  /* Circle container: full width by default, only 50% when zoomed */
  #circle-container {
    position: absolute;
    top: 0; left: 0; bottom: 0;
    width: 100%;
    overflow: hidden;          /* clipping happens here */
    transition: width 250ms ease;
  }
  #circle-container.split {
    width: 50%;
  }

  /* Right panel: hidden by default, shown only when zoomed (and person selected) */
  #right-panel {
    position: absolute;
    top: 0; right: 0; bottom: 0;
    width: 50%;
    display: none;
    background: #ffffff;
    border-left: 1px solid #e6e6e6;
  }
  #right-panel.show { display: block; }

  #panel-header {
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 14px;
    border-bottom: 1px solid #eee;
    background: #fafafa;
  }
  #panel-title {
    font-weight: 700;
    font-size: 13px;
    color: #111;
  }
  #panel-subtitle {
    font-size: 12px;
    color: #666;
    margin-left: 10px;
    font-weight: 500;
  }
  #panel-header-left {
    display: flex;
    align-items: baseline;
    gap: 10px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  #panel-close {
    border: 1px solid #ddd;
    background: #fff;
    border-radius: 6px;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 12px;
  }

  #panel-body {
    position: absolute;
    top: 48px; left: 0; right: 0; bottom: 0;
    overflow: auto;
  }

  /* chain svg */
  #chain-svg {
    width: 100%;
    height: 100%;
    display: block;
    background: #fff;
  }

  /* Tree container (full width) */
  #tree-container {
    position: absolute;
    inset: 0;
    display: none;
  }

  svg {
    width: 100%;
    height: 100%;
    display: block;
    background: #f7f7f7;
  }

  .node { cursor: pointer; }
  .node--leaf { fill: white; }
  .label { font-size: 11px; text-anchor: middle; pointer-events: none; }

  .tooltip {
    position: absolute;
    padding: 8px 10px;
    background: rgba(0,0,0,0.85);
    color: #fff;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    opacity: 0;
    z-index: 100;
    line-height: 1.4;
  }

  /* chain styles */
  .chain-link {
    fill: none;
    stroke: #cfcfcf;
    stroke-width: 2px;
  }
  .chain-card {
    fill: #fff;
    stroke: #d8d8d8;
    stroke-width: 1.5px;
    rx: 10;
    ry: 10;
  }
  .chain-card.manager {
    stroke: #ff9500;
    stroke-width: 2px;
  }
  .chain-card.selected {
    stroke: #007bff;
    stroke-width: 3px;
  }
  .chain-name {
    font-size: 13px;
    font-weight: 700;
    fill: #111;
    text-anchor: middle;
  }
  .chain-title {
    font-size: 12px;
    fill: #666;
    text-anchor: middle;
  }
  .chain-level {
    font-size: 11px;
    fill: #888;
    text-anchor: middle;
  }

  /* Tree styles (from your reference) */
  .org-node rect {
    fill: #fff;
    stroke: #d4c0af;
    rx: 6; ry: 6;
    cursor: pointer;
  }
  .org-node text {
    font-size: 11px;
    text-anchor: middle;
    pointer-events: none;
  }
  .org-link {
    fill: none;
    stroke: #ccc;
    stroke-width: 1.5px;
  }

  /* NEW: zoomed circle title */
  .circle-focus-title {
    font-weight: 800;
    fill: #000;
    font-size: 20px;
    text-anchor: middle;
    pointer-events: none;
  }
</style>

<body>
  <div id="top-ribbon">
    <span class="brand-white">Company</span>
    <span class="brand-red">Organization</span>
  </div>

  <div id="tabs">
    <button id="tab-circle" class="tab-btn active">Circle view</button>
    <button id="tab-tree" class="tab-btn">Tree view</button>
    <div id="search-container">
      <input id="search-input" type="text" placeholder="Search person..." />
      <button id="search-button">Search</button>
    </div>
  </div>

  <div id="content">
    <div id="circle-container">
      <div id="tooltip" class="tooltip"></div>
      <svg id="circle-svg"></svg>
    </div>

    <!-- Right chain panel (shown only when zoomed + person selected) -->
    <div id="right-panel">
      <div id="panel-header">
        <div id="panel-header-left">
          <div id="panel-title">Manager chain</div>
          <div id="panel-subtitle"></div>
        </div>
        <button id="panel-close" title="Close">Close</button>
      </div>
      <div id="panel-body">
        <svg id="chain-svg"></svg>
      </div>
    </div>

    <!-- Tree view (restored) -->
    <div id="tree-container">
      <svg id="org-tree-svg"></svg>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    /* ----------------- globals ----------------- */
    let circleNodesData = [];
    let personById = new Map();   // userId -> person (includes manager_id)
    let viewGlobal = null;
    let focusGlobal = null;
    let circleRootGlobal = null;

    let selectedPersonId = null;

    // Tree globals (restored)
    let fullHierarchyRoot = null;
    let currentTreeHighlightId = null;

    /* ----------------- DOM refs ----------------- */
    const tabCircleBtn = document.getElementById("tab-circle");
    const tabTreeBtn   = document.getElementById("tab-tree");
    const circleContainer = document.getElementById("circle-container");
    const treeContainer   = document.getElementById("tree-container");

    const rightPanel = document.getElementById("right-panel");
    const panelSubtitle = document.getElementById("panel-subtitle");
    const panelClose = document.getElementById("panel-close");

    function showCircle() {
      tabCircleBtn.classList.add("active");
      tabTreeBtn.classList.remove("active");
      circleContainer.style.display = "block";
      treeContainer.style.display = "none";
      // right panel is controlled by zoom state + selected person
    }

    function showTree() {
      tabTreeBtn.classList.add("active");
      tabCircleBtn.classList.remove("active");

      circleContainer.style.display = "none";
      treeContainer.style.display = "block";

      // In tree view: hide chain + reset split (tree is full width)
      rightPanel.classList.remove("show");
      circleContainer.classList.remove("split");

      setTimeout(recenterTree, 50);
    }

    tabCircleBtn.addEventListener("click", showCircle);
    tabTreeBtn.addEventListener("click", showTree);

    panelClose.addEventListener("click", () => {
      selectedPersonId = null;
      panelSubtitle.textContent = "";
      rightPanel.classList.remove("show");
      d3.select("#chain-svg").selectAll("*").remove();
    });

    /* ----------------- circle setup (preserve original geometry) ----------------- */
    const circleSvg = d3.select("#circle-svg");
    const circleWidth = window.innerWidth;   // KEEP FULL WIDTH => preserves pack shape
    const circleHeight = window.innerHeight;
    const margin = 20;

    const gCircle = circleSvg.append("g")
      .attr("transform", `translate(${circleWidth / 2},${circleHeight / 2})`);

    // NEW: a group for a single "focus title" above the current zoomed circle
    const gCircleTitle = circleSvg.append("g");
    const focusCircleTitle = gCircleTitle.append("text")
      .attr("class", "circle-focus-title")
      .style("display", "none");

    const colorScale = d3.scaleOrdinal()
      .domain(["company","portfolio","value_stream","art","product_team","person"])
      .range(["#f1f1f1","#c7e9c0","#9ecae1","#fdd0a2","#d4b9da","#ffffff"]);

    const pack = d3.pack()
      .size([circleWidth - 2 * margin, circleHeight - 2 * margin]) // KEEP => preserves shape
      .padding(3);

    const tooltip = d3.select("#tooltip");

    /* ----------------- chain panel rendering ----------------- */
    const chainSvg = d3.select("#chain-svg");

    function computeManagerChain(userId) {
      const chain = [];
      const seen = new Set();
      let currId = userId;

      while (currId && !seen.has(currId)) {
        seen.add(currId);
        chain.push(currId);

        const p = personById.get(currId);
        const next = p ? p.manager_id : null;
        if (!next || next === currId) break;

        if (!personById.has(next)) {
          chain.push(next);
          break;
        }
        currId = next;
      }
      return chain;
    }

    function renderManagerChain(userId) {
      selectedPersonId = userId;

      const chainBottomUp = computeManagerChain(userId);
      const chainTopDown = [...chainBottomUp].reverse();

      const selected = personById.get(userId);
      panelSubtitle.textContent = selected ? (selected.name || "") : "";

      rightPanel.classList.add("show");

      const w = rightPanel.clientWidth || (window.innerWidth * 0.5);
      const h = rightPanel.clientHeight - 48 || (window.innerHeight - 88);
      chainSvg.attr("width", w).attr("height", h);

      chainSvg.selectAll("*").remove();
      const g = chainSvg.append("g").attr("transform", "translate(0,0)");

      const cardW = Math.min(360, w - 80);
      const cardH = 78;
      const x = w / 2;
      const topPad = 24;
      const gap = 28;

      const n = chainTopDown.length;
      const idealStep = cardH + gap;
      const needed = topPad + n * idealStep;
      const scaleY = needed > h ? (h - topPad) / (n * idealStep) : 1;
      const step = idealStep * scaleY;

      for (let i = 0; i < n - 1; i++) {
        const y1 = topPad + i * step + cardH;
        const y2 = topPad + (i + 1) * step;
        g.append("path")
          .attr("class", "chain-link")
          .attr("d", `M${x},${y1} V${(y1+y2)/2} V${y2}`);
      }

      const nodes = g.selectAll("g.chain-node")
        .data(chainTopDown.map(id => {
          const p = personById.get(id);
          return {
            id,
            name: p?.name || (id === userId ? "Selected person" : "Unknown"),
            title: p?.title || "",
            isSelected: id === userId,
            isManager: id !== userId
          };
        }))
        .enter()
        .append("g")
        .attr("class", "chain-node")
        .attr("transform", (_, i) => `translate(${x - cardW/2},${topPad + i * step})`);

      nodes.append("rect")
        .attr("class", d => d.isSelected ? "chain-card selected" : "chain-card manager")
        .attr("width", cardW)
        .attr("height", cardH);

      nodes.append("text")
        .attr("class", "chain-name")
        .attr("x", cardW / 2)
        .attr("y", 28)
        .text(d => d.name || "");

      nodes.append("text")
        .attr("class", "chain-title")
        .attr("x", cardW / 2)
        .attr("y", 48)
        .text(d => d.title || "");

      nodes.append("text")
        .attr("class", "chain-level")
        .attr("x", cardW / 2)
        .attr("y", 66)
        .text(d => d.isSelected ? "Selected" : "Manager");
    }

    function hideManagerChain() {
      selectedPersonId = null;
      panelSubtitle.textContent = "";
      rightPanel.classList.remove("show");
      chainSvg.selectAll("*").remove();
    }

    /* ----------------- circle zoom mechanics ----------------- */
    function fullOrgView(circleRoot) {
      const k = 0.85;
      const r = circleRoot.r;
      const viewSize = (2 * r) / k;
      return [circleRoot.x, circleRoot.y, viewSize];
    }

    function zoomTo(circlesSel, labelsSel, v, applyLeftShift) {
      const k = Math.min(circleWidth, circleHeight) / v[2];
      viewGlobal = v;

      const xShift = applyLeftShift ? circleWidth * 0.25 : 0;

      circlesSel
        .attr("transform", d => `translate(${(d.x - v[0]) * k - xShift},${(d.y - v[1]) * k})`)
        .attr("r", d => d.r * k);

      labelsSel
        .attr("transform", d => `translate(${(d.x - v[0]) * k - xShift},${(d.y - v[1]) * k})`)
        .style("display", d => (d.parent === focusGlobal && d.r * k > 30) ? "inline" : "none");

      // NEW: show the focused circle's title above it, black + bold
      // Compute focus center in screen coords (same math as circles)
      const fx = (focusGlobal.x - v[0]) * k - xShift + circleWidth / 2;
      const fy = (focusGlobal.y - v[1]) * k + circleHeight / 2;
      const fr = focusGlobal.r * k;

      const title = (focusGlobal && focusGlobal.data) ? (focusGlobal.data.name || "") : "";
      if (title && focusGlobal !== circleRootGlobal) {
        focusCircleTitle
          .attr("x", fx)
          .attr("y", fy - fr - 18)  // above the circle
          .text(title)
          .style("display", "block");
      } else {
        // hide title at full org/root view (or if no name)
        focusCircleTitle.style("display", "none");
      }
    }

    /* ----------------- tree setup (restored) ----------------- */
    const orgSvg = d3.select("#org-tree-svg");
    const orgG  = orgSvg.append("g");
    const treeZoom = d3.zoom().on("zoom", (event) => orgG.attr("transform", event.transform));
    orgSvg.call(treeZoom);

    const treeLayout = d3.tree().nodeSize([180, 120]);
    const boxWidth = 130, boxHeight = 50;

    function updateTree() {
      if (!fullHierarchyRoot) return;

      treeLayout(fullHierarchyRoot);
      const nodes = fullHierarchyRoot.descendants();
      const links = fullHierarchyRoot.links();
      const halfBox = boxHeight / 2;

      orgG.selectAll(".org-link")
        .data(links)
        .join("path")
        .attr("class", "org-link")
        .attr("d", d => {
          const startY = d.source.y + halfBox;
          const endY = d.target.y - halfBox;
          const midY = (startY + endY) / 2;
          return `M${d.source.x},${startY}V${midY}H${d.target.x}V${endY}`;
        });

      const nodeG = orgG.selectAll(".org-node")
        .data(nodes)
        .join("g")
        .attr("class", "org-node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .on("click", (event, d) => {
          if (d.children) { d._children = d.children; d.children = null; }
          else if (d._children) { d.children = d._children; d._children = null; }
          updateTree();
        });

      nodeG.selectAll("rect")
        .data(d => [d])
        .join("rect")
        .attr("x", -boxWidth / 2)
        .attr("y", -boxHeight / 2)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("stroke", d => d.data.userId === currentTreeHighlightId ? "#007bff" : "#d4c0af")
        .attr("stroke-width", d => d.data.userId === currentTreeHighlightId ? 3 : 1.2);

      nodeG.selectAll(".n-text")
        .data(d => [d])
        .join("text")
        .attr("class", "n-text")
        .attr("y", -6)
        .attr("font-weight", "bold")
        .text(d => d.data.name);

      nodeG.selectAll(".t-text")
        .data(d => [d])
        .join("text")
        .attr("class", "t-text")
        .attr("y", 10)
        .attr("fill", "#666")
        .text(d => d.data.title || "");
    }

    function recenterTree() {
      const w = treeContainer.clientWidth || window.innerWidth;
      const t = d3.zoomIdentity.translate(w / 2, 80).scale(1);
      orgSvg.transition().duration(500).call(treeZoom.transform, t);
    }

    function highlightInTree(userId) {
      currentTreeHighlightId = userId;

      let targetNode = null;
      fullHierarchyRoot.each(d => {
        if (d.data.userId === userId) targetNode = d;
      });

      if (targetNode) {
        let curr = targetNode.parent;
        while (curr) {
          if (curr._children) { curr.children = curr._children; curr._children = null; }
          curr = curr.parent;
        }
      }

      updateTree();
    }

    /* ----------------- load data (circle + tree) ----------------- */
    d3.json("employees_hierarchy.json").then(data => {
      const circleRoot = d3.hierarchy(data)
        .sum(d => d.level === "person" ? 1 : 0)
        .sort((a, b) => b.value - a.value);

      circleRootGlobal = circleRoot;
      focusGlobal = circleRoot;

      circleRoot.each(d => {
        if (!d.children && d.data.level === "person") {
          personById.set(d.data.userId, d.data);
        }
      });

      circleNodesData = pack(circleRoot).descendants();
      viewGlobal = fullOrgView(circleRoot);

      const circles = gCircle.selectAll("circle")
        .data(circleNodesData)
        .join("circle")
          .attr("class", d => d.parent ? (d.children ? "node" : "node node--leaf") : "node node--root")
          .attr("fill", d => colorScale(d.data.level || (d.children ? "company" : "person")))
          .on("click", (event, d) => {
            const isPerson = (!d.children && d.data.level === "person");
            const target = (d.children || !isPerson) ? d : d.parent;

            if (isPerson && d.data.userId) {
              renderManagerChain(d.data.userId);
              highlightInTree(d.data.userId);
            } else {
              hideManagerChain();
              currentTreeHighlightId = null;
              updateTree();
            }

            zoomToCircleInternal(target);
            event.stopPropagation();
          })
          .on("mousemove", (event, d) => {
            if (!d.children && d.data.level === "person") {
              const p = d.data;
              tooltip.style("opacity", 1)
                .style("left", (event.pageX + 15) + "px")
                .style("top",  (event.pageY + 15) + "px")
                .html(`<strong>${p.name || ""}</strong><br>${p.title || ""}`);
            }
          })
          .on("mouseleave", () => tooltip.style("opacity", 0));

      const labels = gCircle.selectAll("text.node-label")
        .data(circleNodesData.filter(d => d !== circleRoot))
        .join("text")
          .attr("class", "label node-label")
          .style("display", "none")
          .text(d => d.data.name);

      function zoomToCircleInternal(d) {
        focusGlobal = d;

        const zoomSize = d.r * 2.8;
        const target = [d.x, d.y, zoomSize];

        const isZoomed = (d !== circleRoot);

        circleContainer.classList.toggle("split", isZoomed);

        if (isZoomed && selectedPersonId) rightPanel.classList.add("show");
        if (!isZoomed) hideManagerChain();

        circleSvg.transition().duration(750).tween("zoom", () => {
          const i = d3.interpolateZoom(viewGlobal, target);
          return t => zoomTo(circles, labels, i(t), isZoomed);
        });
      }

      // initial centered + full width
      circleContainer.classList.remove("split");
      rightPanel.classList.remove("show");
      focusGlobal = circleRoot; // ensure title logic knows we're at root
      zoomTo(circles, labels, fullOrgView(circleRoot), false);

      // clicking background resets
      circleSvg.on("click", (event) => {
        if (event.target.tagName === "svg") {
          hideManagerChain();
          currentTreeHighlightId = null;
          updateTree();
          focusGlobal = circleRoot;
          zoomToCircleInternal(circleRoot);
        }
      });

      // search: exact name match
      document.getElementById("search-button").addEventListener("click", () => {
        const val = document.getElementById("search-input").value.trim().toLowerCase();
        if (!val) return;

        const personNode = circleNodesData.find(d =>
          !d.children &&
          d.data.level === "person" &&
          (d.data.name || "").toLowerCase() === val
        );

        if (personNode) {
          renderManagerChain(personNode.data.userId);
          highlightInTree(personNode.data.userId);
          zoomToCircleInternal(personNode.parent || personNode);
          showCircle();
        }
      });

      /* ------------- Build Tree hierarchy (restored) ------------- */
      const people = [];
      circleRoot.each(d => { if (!d.children && d.data.level === "person") people.push(d.data); });

      const nodeById = new Map(people.map(p => [p.userId, { ...p, children: [] }]));
      const managerRoot = { id: "ROOT", name: "Organization", title: "Global View", children: [] };

      nodeById.forEach(n => {
        const parent = nodeById.get(n.manager_id) || managerRoot;
        parent.children.push(n);
      });

      fullHierarchyRoot = d3.hierarchy(managerRoot);

      fullHierarchyRoot.descendants().forEach(d => {
        if (d.depth > 0 && d.children) { d._children = d.children; d.children = null; }
      });

      updateTree();
    });
  </script>
</body>
